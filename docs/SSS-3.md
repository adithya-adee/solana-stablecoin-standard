# SSS-3: Private Preset

SSS-3 is the privacy-preserving stablecoin preset. It uses Token-2022's ConfidentialTransferMint extension to encrypt token balances and transfer amounts using twisted ElGamal encryption with zero-knowledge proofs. An auditor key provides regulatory access to encrypted data without exposing it publicly.

This is SSS's key differentiator. No other stablecoin standard on Solana provides integrated confidential transfer support with an auditor compliance model.

## Token-2022 Extensions

| Extension                | Configuration                               | Purpose                          |
| ------------------------ | ------------------------------------------- | -------------------------------- |
| MetadataPointer          | Authority: config PDA, Address: mint        | On-chain token metadata          |
| PermanentDelegate        | Delegate: config PDA                        | Enables burn-from-any and seize  |
| ConfidentialTransferMint | Authority: config PDA, Auditor: ElGamal key | Encrypted balances and transfers |

## Why Not Transfer Hooks?

Transfer hooks and confidential transfers are **incompatible** in Token-2022. This is a protocol-level constraint: the transfer hook interface requires the transfer amount as a parameter, but confidential transfers encrypt the amount. Token-2022 cannot pass an encrypted amount to a hook that expects a plaintext `u64`.

SSS-3 replaces hook-based compliance with the **auditor key model**: an ElGamal public key embedded in the ConfidentialTransferMint extension. Every confidential transfer encrypts the amount for both the sender/receiver AND the auditor. The auditor (a regulator or compliance officer with the corresponding private key) can decrypt any transfer amount without the amount being visible on-chain.

## Cryptographic Primitives

### Twisted ElGamal Encryption

Token-2022 uses a variant of ElGamal encryption that operates on the Curve25519 group. Each token account has an ElGamal keypair used to encrypt its confidential balance.

- **Public key** (32 bytes) -- Stored on-chain in the token account's confidential transfer extension
- **Secret key** (32 bytes) -- Held by the account owner, never on-chain

In production, the ElGamal keypair is deterministically derived from the wallet's signing key and the token account address using the `solana-zk-sdk` Rust crate.

### AES-128 Encryption

The "decryptable available balance" field in the confidential transfer extension is encrypted with AES-128. This allows the account owner to quickly read their balance without performing expensive ElGamal decryption.

### Zero-Knowledge Proofs

Confidential transfers require three ZK proofs, all generated by the `solana-zk-sdk`:

1. **Range proof** (Bulletproofs) -- Proves the transfer amount is non-negative and the sender's remaining balance is non-negative. This prevents double-spending without revealing balances.

2. **Equality proof** (Sigma protocol) -- Proves the sender's ElGamal ciphertext and the Pedersen commitment encode the same value. This links the encrypted amount to the commitment used in the range proof.

3. **Ciphertext validity proof** -- Proves the new ciphertexts for sender, recipient, and auditor are well-formed encryptions of the same amount under their respective public keys.

## Confidential Transfer Lifecycle

### 1. Configure Account for Confidential Transfers

Before using confidential transfers, each token account must be configured with an ElGamal public key:

```
Token-2022::ConfidentialTransferExtension::ConfigureAccount
  - token_account (writable)
  - mint
  - owner (signer)
  - ElGamal public key (32 bytes)
  - Decryptable zero balance (AES-encrypted zero)
```

### 2. Deposit (Public to Confidential)

Move tokens from the public balance to the pending confidential balance. The amount is visible on-chain during this step. No ZK proofs required.

```
Public Balance: 1000 -> 0
Pending Balance: 0 -> 1000 (encrypted)
```

```typescript
await sss.confidential.deposit(tokenAccount, 1_000_000n, 6);
```

### 3. Apply Pending Balance

Credit the pending balance to the available confidential balance. No ZK proofs required.

```
Pending Balance: 1000 -> 0
Available Balance: 0 -> 1000 (encrypted)
```

```typescript
await sss.confidential.applyPending(tokenAccount);
```

### 4. Confidential Transfer

Transfer tokens between confidential balances. The amount is encrypted and NOT visible on-chain. Requires all three ZK proofs.

```
Sender Available: 1000 -> 700 (encrypted)
Recipient Pending: 0 -> 300 (encrypted)
Auditor: can decrypt 300 from auditor ciphertext
```

**This operation requires the Rust proof service** because the `solana-zk-sdk` crate (which generates the ZK proofs) is only available in Rust. The TypeScript SDK throws an error for this operation with guidance on the proof service.

### 5. Withdraw (Confidential to Public)

Move tokens from the confidential balance back to the public balance. Requires range and equality proofs.

```
Available Balance: 700 -> 400 (encrypted)
Public Balance: 0 -> 300
```

**This operation also requires the Rust proof service.**

## Auditor Key Architecture

The auditor key is an ElGamal public key set during mint creation:

```typescript
const sss = await SSS.create(provider, {
  preset: 'sss-3',
  name: 'Private Dollar',
  symbol: 'pUSD',
  decimals: 6,
});
```

The `Sss3MintOptions` interface accepts an optional `auditorElGamalPubkey` (32-byte `Uint8Array`). If omitted, a 32-byte zero key is used (which means no auditor -- suitable for testing).

### How Auditing Works

1. Every confidential transfer encrypts the amount for three parties:
   - Sender (using sender's ElGamal public key)
   - Recipient (using recipient's ElGamal public key)
   - Auditor (using auditor's ElGamal public key embedded in the mint)

2. The ciphertext validity proof ensures all three encryptions encode the same amount.

3. The auditor (e.g., a regulator) holds the corresponding ElGamal secret key and can decrypt any transfer amount from the on-chain transaction data.

4. Regular users and observers see only encrypted ciphertexts. The auditor key does NOT give access to account balances -- only to individual transfer amounts.

### Auditor Key Rotation

The ConfidentialTransferMint authority (config PDA) can update the auditor key. New transfers use the new key; existing ciphertexts remain encrypted under the old key.

## Proof Service Requirements

The Rust proof service is a separate component that generates ZK proofs for confidential operations:

```
Client (TypeScript)          Proof Service (Rust)          Solana
       |                            |                        |
       | Request proof for transfer |                        |
       |--------------------------->|                        |
       |                            |                        |
       |                            | Generate:              |
       |                            |  - Range proof         |
       |                            |  - Equality proof      |
       |                            |  - Ciphertext validity |
       |                            |                        |
       | Return proof bytes         |                        |
       |<---------------------------|                        |
       |                            |                        |
       | Submit tx with proofs      |                        |
       |------------------------------------------->         |
       |                            |                        |
       |                            |  Token-2022 verifies   |
       |                            |  proofs on-chain       |
       |                            |                        |
```

The proof service needs:

- `solana-zk-sdk` Rust crate
- Account owner's ElGamal secret key
- Current encrypted balance (to compute the new balance after transfer)
- Recipient's ElGamal public key (from their token account)
- Auditor's ElGamal public key (from the mint)
- Transfer amount

### Security Considerations for the Proof Service

- The proof service handles secret keys and must run in a trusted environment
- Communication between client and proof service should be encrypted (TLS)
- The proof service should authenticate callers to prevent unauthorized proof generation
- Consider running the proof service as a sidecar or in a TEE (Trusted Execution Environment)

## ConfidentialTransferMint Instruction Encoding

The SDK manually encodes the `InitializeConfidentialTransferMint` instruction because `@solana/spl-token` does not provide a builder for it:

```
Instruction data (67 bytes, Pod/fixed-size):
  [0]      Extension discriminator: 27 (ConfidentialTransferExtension)
  [1]      Sub-instruction: 0 (InitializeMint)
  [2-33]   OptionalNonZeroPubkey authority (32 bytes, zeros = None)
  [34]     PodBool auto_approve_new_accounts (0 or 1)
  [35-66]  OptionalNonZeroElGamalPubkey auditor (32 bytes, zeros = None)
```

## Use Cases

- **Privacy-preserving stablecoins** -- Users transact without exposing balances or amounts publicly
- **Institutional settlement** -- Private OTC trades with regulatory visibility via auditor key
- **Salary payments** -- Pay employees in stablecoins without public salary disclosure
- **Medical/legal payments** -- Sensitive payments requiring privacy by default

## Limitations

- **No transfer hooks** -- Blacklist enforcement is not available at the protocol level. Compliance relies on the auditor key for post-hoc investigation.
- **Proof generation requires Rust** -- The `solana-zk-sdk` is Rust-only. No TypeScript implementation exists for the ZK proof generation.
- **Higher compute cost** -- Confidential transfers consume more compute units than standard transfers due to proof verification.
- **Account configuration required** -- Each token account must be configured for confidential transfers before use.
- **Deposit/withdraw visibility** -- Moving tokens between public and confidential balances exposes the amount. Only confidential-to-confidential transfers are fully private.

## Example: Full Confidential Flow

```typescript
import { SSS, generateTestElGamalKeypair } from '@stbr/sss-token';

// Create SSS-3 stablecoin with auditor key
const auditorKeys = generateTestElGamalKeypair(); // Use real derivation in production
const sss = await SSS.create(provider, {
  preset: 'sss-3',
  name: 'Private Dollar',
  symbol: 'pUSD',
  decimals: 6,
});

// Grant minter role and mint tokens (public balance)
await sss.roles.grant(minterWallet, 'minter');
await sss.mint({ recipient: userTokenAccount, amount: 10_000_000n });

// Move tokens into confidential balance
await sss.confidential.deposit(userTokenAccount, 10_000_000n, 6);
await sss.confidential.applyPending(userTokenAccount);

// Confidential transfer (requires Rust proof service)
// await sss.confidential.transfer(senderAccount, recipientAccount, 5_000_000n);
// ^ Throws: "Confidential transfer requires Rust proof service"

// Withdraw back to public balance (requires Rust proof service)
// await sss.confidential.withdraw(userTokenAccount, 3_000_000n, 6);
// ^ Throws: "Confidential withdraw requires Rust proof service"
```

## Comparison: SSS-2 vs SSS-3 Compliance

| Aspect            | SSS-2 (Transfer Hook)           | SSS-3 (Auditor Key)              |
| ----------------- | ------------------------------- | -------------------------------- |
| Compliance timing | Preventive (blocks at transfer) | Detective (audit after transfer) |
| Privacy           | None (all public)               | Full (encrypted amounts)         |
| Blacklist         | On-chain, automatic             | Not available                    |
| KYC gating        | Frozen-by-default               | Not available                    |
| Regulatory access | N/A (all public)                | Auditor decrypts amounts         |
| Compute cost      | Moderate (hook invocation)      | Higher (proof verification)      |
