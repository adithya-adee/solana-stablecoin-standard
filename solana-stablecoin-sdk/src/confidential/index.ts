import {
  Connection,
  PublicKey,
  TransactionInstruction,
} from "@solana/web3.js";
import { TOKEN_2022_PROGRAM_ID } from "@solana/spl-token";

export { generateTestElGamalKeypair, generateTestAesKey, deriveElGamalKeypair } from "./keys";

/**
 * Confidential transfer operations for SSS-3 stablecoins.
 *
 * Token-2022's confidential transfer extension encrypts token balances
 * using twisted ElGamal encryption. Operations that only move tokens
 * between public and pending-confidential states (deposit, apply pending)
 * do NOT require ZK proofs. Operations that touch encrypted balances
 * (transfer, withdraw) require range proofs, equality proofs, and
 * ciphertext validity proofs generated by the Rust `solana-zk-sdk`.
 *
 * The Token-2022 confidential transfer instruction discriminator is byte 27,
 * followed by a sub-instruction byte:
 *   - InitializeMint = 0
 *   - ConfigureAccount = 2
 *   - Deposit = 5
 *   - Withdraw = 6
 *   - Transfer = 7
 *   - ApplyPendingBalance = 8
 */
export class ConfidentialOps {
  constructor(
    private _connection: Connection,
    private mint: PublicKey,
    private owner: PublicKey,
  ) {}

  /**
   * Build a deposit instruction that moves tokens from the public balance
   * to the pending confidential balance of a token account.
   *
   * No ZK proofs required â€” the amount is publicly visible on-chain
   * during the deposit. Once applied (via applyPendingBalance), the
   * tokens become part of the encrypted confidential balance.
   *
   * Instruction data layout: [27, 5, amount (8 bytes LE), decimals (1 byte)]
   * Accounts: token_account (writable), mint (readonly), owner (signer)
   */
  buildDepositInstruction(
    tokenAccount: PublicKey,
    amount: bigint,
    decimals: number,
  ): TransactionInstruction {
    const data = Buffer.alloc(11);
    data.writeUInt8(27, 0); // ConfidentialTransferExtension discriminator
    data.writeUInt8(5, 1); // Deposit sub-instruction
    data.writeBigUInt64LE(amount, 2); // amount (8 bytes)
    data.writeUInt8(decimals, 10); // decimals (1 byte)

    return new TransactionInstruction({
      programId: TOKEN_2022_PROGRAM_ID,
      keys: [
        { pubkey: tokenAccount, isSigner: false, isWritable: true },
        { pubkey: this.mint, isSigner: false, isWritable: false },
        { pubkey: this.owner, isSigner: true, isWritable: false },
      ],
      data,
    });
  }

  /**
   * Build an apply-pending-balance instruction that credits the pending
   * confidential balance into the available confidential balance.
   *
   * No ZK proofs required. The account owner calls this after deposits
   * or incoming confidential transfers to make the pending tokens
   * available for confidential transfers or withdrawals.
   *
   * Instruction data layout: [27, 8]
   * Accounts: token_account (writable), owner (signer)
   */
  buildApplyPendingBalanceInstruction(
    tokenAccount: PublicKey,
  ): TransactionInstruction {
    const data = Buffer.alloc(2);
    data.writeUInt8(27, 0); // ConfidentialTransferExtension discriminator
    data.writeUInt8(8, 1); // ApplyPendingBalance sub-instruction

    return new TransactionInstruction({
      programId: TOKEN_2022_PROGRAM_ID,
      keys: [
        { pubkey: tokenAccount, isSigner: false, isWritable: true },
        { pubkey: this.owner, isSigner: true, isWritable: false },
      ],
      data,
    });
  }

  /**
   * Build a confidential transfer instruction.
   *
   * Confidential transfers require three ZK proofs:
   * 1. **Range proof**: proves the transfer amount is non-negative and
   *    won't cause the sender's balance to underflow
   * 2. **Equality proof**: proves the sender's ElGamal ciphertext and
   *    the Pedersen commitment encode the same value
   * 3. **Ciphertext validity proof**: proves the new ciphertexts for
   *    sender, recipient, and auditor are well-formed
   *
   * These proofs must be generated by the `solana-zk-sdk` Rust crate.
   * No TypeScript implementation exists.
   *
   * @throws Always throws - requires Rust proof service
   */
  buildTransferInstruction(
    _senderTokenAccount: PublicKey,
    _recipientTokenAccount: PublicKey,
    _amount: bigint,
  ): TransactionInstruction {
    throw new Error(
      "Confidential transfers require ZK proofs (range, equality, ciphertext validity) " +
      "that must be generated by a Rust proof service. " +
      "See docs/SSS-3.md for the proof service architecture.",
    );
  }

  /**
   * Build a confidential withdraw instruction.
   *
   * Withdrawals move tokens from the confidential balance back to the
   * public balance. This requires:
   * 1. **Range proof**: proves the remaining confidential balance is non-negative
   * 2. **Equality proof**: proves consistency between ElGamal ciphertext
   *    and Pedersen commitment
   *
   * These proofs must be generated by the `solana-zk-sdk` Rust crate.
   *
   * @throws Always throws - requires Rust proof service
   */
  buildWithdrawInstruction(
    _tokenAccount: PublicKey,
    _amount: bigint,
    _decimals: number,
  ): TransactionInstruction {
    throw new Error(
      "Confidential withdrawals require ZK proofs (range, equality) " +
      "that must be generated by a Rust proof service. " +
      "See docs/SSS-3.md for the proof service architecture.",
    );
  }
}
